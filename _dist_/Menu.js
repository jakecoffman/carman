import './Menu.css.proxy.js';
/* src\Menu.svelte generated by Svelte v3.23.2 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	mount_component,
	null_to_empty,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../web_modules/svelte/internal.js";

import Phaser from "../web_modules/phaser.js";
import Drive from "./Drive.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (180:2) {#if player.joined}
function create_if_block(ctx) {
	let li;
	let div0;
	let t0;
	let t1_value = /*player*/ ctx[5].id + 1 + "";
	let t1;
	let t2;
	let div1;
	let t3;
	let t4_value = /*player*/ ctx[5].score + "";
	let t4;
	let t5;
	let li_class_value;

	return {
		c() {
			li = element("li");
			div0 = element("div");
			t0 = text("Player ");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text("Score ");
			t4 = text(t4_value);
			t5 = space();
			attr(li, "class", li_class_value = "" + (null_to_empty(getColor(/*player*/ ctx[5])) + " svelte-au0xn4"));
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, div0);
			append(div0, t0);
			append(div0, t1);
			append(li, t2);
			append(li, div1);
			append(div1, t3);
			append(div1, t4);
			append(li, t5);
		},
		p(ctx, dirty) {
			if (dirty & /*players*/ 1 && t1_value !== (t1_value = /*player*/ ctx[5].id + 1 + "")) set_data(t1, t1_value);
			if (dirty & /*players*/ 1 && t4_value !== (t4_value = /*player*/ ctx[5].score + "")) set_data(t4, t4_value);

			if (dirty & /*players*/ 1 && li_class_value !== (li_class_value = "" + (null_to_empty(getColor(/*player*/ ctx[5])) + " svelte-au0xn4"))) {
				attr(li, "class", li_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (179:0) {#each players as player}
function create_each_block(ctx) {
	let if_block_anchor;
	let if_block = /*player*/ ctx[5].joined && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*player*/ ctx[5].joined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let ul;
	let t0;
	let p;
	let t1;
	let t2;
	let drive;
	let updating_players;
	let current;
	let each_value = /*players*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function drive_players_binding(value) {
		/*drive_players_binding*/ ctx[3].call(null, value);
	}

	let drive_props = { game: /*game*/ ctx[1] };

	if (/*players*/ ctx[0] !== void 0) {
		drive_props.players = /*players*/ ctx[0];
	}

	drive = new Drive({ props: drive_props });
	binding_callbacks.push(() => bind(drive, "players", drive_players_binding));

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			p = element("p");
			t1 = text(/*middleText*/ ctx[2]);
			t2 = space();
			create_component(drive.$$.fragment);
			attr(ul, "class", "svelte-au0xn4");
			attr(p, "class", "middle-text svelte-au0xn4");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t0, anchor);
			insert(target, p, anchor);
			append(p, t1);
			insert(target, t2, anchor);
			mount_component(drive, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*getColor, players*/ 1) {
				each_value = /*players*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*middleText*/ 4) set_data(t1, /*middleText*/ ctx[2]);
			const drive_changes = {};
			if (dirty & /*game*/ 2) drive_changes.game = /*game*/ ctx[1];

			if (!updating_players && dirty & /*players*/ 1) {
				updating_players = true;
				drive_changes.players = /*players*/ ctx[0];
				add_flush_callback(() => updating_players = false);
			}

			drive.$set(drive_changes);
		},
		i(local) {
			if (current) return;
			transition_in(drive.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(drive.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(p);
			if (detaching) detach(t2);
			destroy_component(drive, detaching);
		}
	};
}

const carColors = 4;

function getColor(player) {
	if (player.color === 0) {
		return "red";
	}

	if (player.color === 1) {
		return "purple";
	}

	if (player.color === 2) {
		return "green";
	}

	if (player.color === 3) {
		return "blue";
	}
}

function instance($$self, $$props, $$invalidate) {
	let { game } = $$props;
	let { players = [] } = $$props;
	let middleText = `Press A on a gamepad or SPACE to play alone`;

	class MenuScene extends Phaser.Scene {
		constructor() {
			super({ key: "menu" });
		}

		preload() {
			this.load.spritesheet("cars", "cars.png", { frameWidth: 32, frameHeight: 32 });
		}

		create() {
			this.playerText = [
				this.add.text(100, 100, ""),
				this.add.text(500, 100, ""),
				this.add.text(100, 500, ""),
				this.add.text(500, 500, "")
			];

			$$invalidate(0, players = []);
			const startingPositions = [[132, 132], [532, 132], [132, 532], [532, 542]];

			for (let i = 0; i < startingPositions.length; i++) {
				const pos = startingPositions[i];

				const player = {
					id: i,
					car: this.add.sprite(pos[0], pos[1], "cars", i),
					keyboard: false,
					pad: null,
					color: i,
					joined: false,
					ready: false,
					score: 0
				};

				players.push(player);
			}

			players.forEach(player => {
				player.car.setVisible(false);
			});

			$$invalidate(0, players);

			this.controllerPoller = setInterval(
				() => {
					for (let pad of this.input.gamepad.gamepads) {
						if (!pad) {
							continue;
						}

						if (!players[pad.index].pad) {
							this.initControllers(pad);
						}
					}
				},
				1000
			);

			this.input.gamepad.on("connected", pad => {
				console.log("connected callback", pad.index);
				this.initControllers(pad);
			});

			this.input.keyboard.once("keyup_SPACE", () => {
				$$invalidate(2, middleText = "");

				$$invalidate(0, players = [
					{
						id: 0,
						keyboard: true,
						color: Phaser.Math.RND.between(0, 3),
						joined: true,
						ready: true,
						score: 0
					}
				]);

				this.scene.start("drive", { players });
			});

			this.allReady = false;
			this.playing = false;

			if (this.input.gamepad.gamepads.length > 0) {
				for (let pad of this.input.gamepad.gamepads) {
					this.initControllers(pad);
				}
			}

			this.input.gamepad.on("disconnected", pad => {
				console.log("pad", pad.index, "disconnected");
				$$invalidate(0, players[pad.index].pad = pad, players);
				$$invalidate(0, players[pad.index].joined = false, players);
			});
		}

		initControllers(pad) {
			$$invalidate(2, middleText = "");
			this.playerText[pad.index].setText("press A to join");
			const player = players[pad.index];
			player.pad = pad;

			player.pad.on("down", (index, value, button) => {
				if (this.playing) {
					return;
				}

				console.log("player", pad.index, "pressed", index);

				if (index === 14 && !player.ready) {
					player.color--;

					if (player.color < 0) {
						player.color = carColors - 1;
					}

					const x = player.car.x;
					const y = player.car.y;
					player.car.destroy();
					player.car = this.add.sprite(x, y, "cars", player.color);
				} else if (index === 15 && !player.ready) {
					player.color++;

					if (player.color >= carColors) {
						player.color = 0;
					}

					const x = player.car.x;
					const y = player.car.y;
					player.car.destroy();
					player.car = this.add.sprite(x, y, "cars", player.color);
				} else if (index === 1) {
					// B
					if (player.ready) {
						player.ready = false;
						this.allReady = false;
						$$invalidate(2, middleText = "");
						this.playerText[pad.index].setText("select car");
					} else if (player.joined) {
						player.joined = false;
						player.car.setVisible(false);
						this.playerText[pad.index].setText("press A to join");
					}
				} else if (index === 0) {
					// A
					if (!player.joined) {
						player.joined = true;
						this.playerText[pad.index].setText("select car");
						player.car.setVisible(true);
					} else if (!player.ready) {
						player.ready = true;
						this.playerText[pad.index].setText("waiting for others");

						if (!players.some(p => p.joined && !p.ready)) {
							this.allReady = true;
							$$invalidate(2, middleText = "press A to play");
						}
					} else if (this.allReady) {
						$$invalidate(2, middleText = "");

						this.scene.launch("drive", {
							players: players.filter(p => p.joined),
							input: this.input
						});

						clearInterval(this.controllerPoller);
						this.playing = true;
					}
				}

				// tell svelte to react
				$$invalidate(0, players[pad.index] = player, players);
			});
		}
	}

	game.scene.add("menu", MenuScene, true);

	function drive_players_binding(value) {
		players = value;
		$$invalidate(0, players);
	}

	$$self.$set = $$props => {
		if ("game" in $$props) $$invalidate(1, game = $$props.game);
		if ("players" in $$props) $$invalidate(0, players = $$props.players);
	};

	return [players, game, middleText, drive_players_binding];
}

class Menu extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { game: 1, players: 0 });
	}
}

export default Menu;